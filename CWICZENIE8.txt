USE AdventureWorks2012

/*Wykorzystując bazę danych AdventureWorks, zrealizuj poniższe zadania.
1. Przygotuj blok anonimowy, który:
- znajdzie średnią stawkę wynagrodzenia pracowników, 
- wyświetli szczegóły pracowników, których stawka wynagrodzenia jest niższa niż średnia.*/

BEGIN
SELECT AVG (Rate) FROM HumanResources.EmployeePayHistory;
END;
BEGIN
SELECT FirstName, LastName, Rate FROM Person.Person p INNER JOIN
HumanResources.EmployeePayHistory h ON
p.BusinessEntityID=h.BusinessEntityID
WHERE  h.Rate < (SELECT AVG (Rate) FROM HumanResources.EmployeePayHistory);
END;

/*2.Utwórz funkcję, która zwróci datę wysyłki określonego zamówienia.*/

SELECT * FROM Purchasing.PurchaseOrderDetail;
CREATE FUNCTION Sales (@PurchaseOrderID INT) RETURNS DATETIME
AS
BEGIN
DECLARE @shipdate DATETIME
SELECT @shipdate = DueDate
FROM  Purchasing.PurchaseOrderDetail WHERE 
PurchaseOrderID = @PurchaseOrderID
RETURN @shipdate
END

SELECT dbo.Sales(254)

/*3. Utwórz procedurę składowaną, która jako parametr przyjmuję nazwę produktu, a jako 
rezultat wyświetla jego identyfikator, numer i dostępność.*/

CREATE PROC produclist @name VARCHAR(50)
AS
BEGIN
PRINT 'Produkt'
SELECT ProductID, ProductNumber, MakeFlag as Dostepnosc
FROM Production.Product
WHERE Name = @name
END

EXECUTE produclist 'BB Ball Bearing'

/*4. Utwórz funkcję, która zwraca numer karty kredytowej dla konkretnego zamówienia*/

CREATE FUNCTION NumberCard (@SalesOrderID INT) RETURNS NVARCHAR (25)
AS
BEGIN
DECLARE @kart NVARCHAR(25)
SELECT @kart = CardNumber 
FROM Sales.SalesOrderHeader s JOIN Sales.CreditCard c
ON s.CreditCardID = c.CreditCardID
WHERE SalesOrderID = @SalesOrderID
IF (@kart IS NULL)
SET @kart = 0
RETURN 
END

SELECT dbo.NumberCard (43661)


/*5. Utwórz procedurę składowaną, która jako parametry wejściowe przyjmuje dwie liczby, num1
i num2, a zwraca wynik ich dzielenia. Ponadto wartość num1 powinna zawsze być większa niż 
wartość num2. Jeżeli wartość num1 jest mniejsza niż num2, wygeneruj komunikat o błędzie 
„Niewłaściwie zdefiniowałeś dane wejściowe” */

CREATE PROCEDURE Podziel @num1 INT, @num2 INT
AS 
BEGIN
 DECLARE @dziel INT
    IF @num1 < @num2
  PRINT ('Niewłaściwie zdefiniowałeś dane wejściowe')
 ELSE
 SET @dziel=@num1/@num2
 PRINT @dziel
END

EXECUTE Podziel 15, 3 


/*6. Napisz procedurę, która jako parametr przyjmie NationalIDNumber danej osoby, a zwróci 
stanowisko oraz liczbę dni urlopowych i chorobowych.*/

CREATE PROC nation @number NVARCHAR(15)
AS
BEGIN
SELECT JobTitle, (VacationHours/24) as DniUrlopu, (SickLeaveHours/24) as DniChorobowe
FROM HumanResources.Employee
WHERE NationalIDNumber = @number
END

EXECUTE nation 295847284

/* 7.Napisz procedurę będącą kalkulatorem walutowym. Wykorzystaj dwie tabele: Sales.Currency 
  oraz Sales.CurrencyRate.Parametrami wejściowymi mają być: kwota, 
  waluty oraz data (CurrencyRateDate).
  Przyjmij, iż zawsze jedną ze stron jest dolar amerykański (USD). 
  Zaimplementuj kalkulację obustronną, tj: 1400 USD → PLN lub PLN → USD. */

CREATE PROCEDURE Call2 (@k MONEY, @w NCHAR, @d DATETIME)
AS 
BEGIN
SELECT 
     S.AverageRate , S.ToCurrencyCode, C.Name, S.CurrencyRateDate,
	 S.ToCurrencyCode , @k/S.AverageRate AS TOUSD , S.ToCurrencyCode, 
	 S.ToCurrencyCode, @k*S.AverageRate AS FROMUSD
	 
FROM Sales.CurrencyRate S
INNER JOIN Sales.Currency C
ON S.ToCurrencyCode = C.CurrencyCode
WHERE S.ToCurrencyCode = @w AND S.CurrencyRateDate = @d
END

EXEC Call2 300, 'AUD', '2011-05-31' 







































